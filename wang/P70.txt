1.
循环存储,把ai,j存放到处理器pk,l的s,t 位置
aij=(ast)kl
i, j, k, l, s, t应满足如下关系
k = i mod p
l = j mod q
s = i / p
t = j / q


2. 
矩阵A和向量b按行分块存储在p个处理器中，处理器pi中存了A的第i行Ai以及b的第i个元素bi，
所求x+=Ax+b，可以在处理器pi中求Ai和x的乘积，然后在pi中把求得的Aix和bi相加，pi中存的
即为x+的第i个元素。
无论第一次x在哪里，迭代后的x的块会分布在不同的处理器中
matvec.c

3.复杂性有两个方面:数据交换量DTA和计算量CA
(1)列列分块:
A,B,C的列被均匀的分到p个处理器上,每个处理器分到k/p=K列
processors:p
A:m*k, k = Kp
B:k*n, k = Kp
C:m*n

# DTA
一个处理器一次发送自己存储的a的K列长度为m的数据,需要发送p-1次,接受的数据和发送的相同
所以,一个处理器上的数据交换量
DTA = 2*m*K*(p-1)=2*m*(k-K)

传送长度为N的数据的复杂度为a*N+b
所以,复杂度为a*DTA+b

# CA
列列分块的方法并没有改变矩阵乘法的计算量m*n*k,只是分配到了p个处理器上,
所以,一个处理器的计算量
CA = m*n*k/p

(2)cannon算法
A,B,C都是m*m分块矩阵,每块n*n个元素
A:m*m
B:m*m
C:m*m
把A,B,C分到p=m*m个处理器上,每个处理器分到n*n的一个块

一个处理器上的数据是A:n*n和B:n*n
一个处理器会把自己存储的A广播到同一行的m-1个处理器m次,并接受m个数据A
一个处理器会把自己存储的B发送到同一列的下一个处理器m-1次,并m-1次接受数据B
DTA= n*n*m*2+n*n*(m-1)*2=2*(2m-1)*n*n

cannon算法也没有改变矩阵乘法的计算量m*n*k,只是分配到了p个处理器上,
所以,一个处理器的计算量
CA = m*n*k/p


4.
请用自己的理解给出cannon算法的描述
cannon算法，首先，对矩阵A和矩阵B分块成Aij和Bij，并按行列对齐,矩阵A的块行循环移位，矩阵B的块列循环移位，使得A的第i行和B的第j列中的对应元素依次移位到ij块内，并相乘相加得到Cij
例如3*3分块矩阵A,B如下
A00 	A01 	A02
B00		B01 	B02

A10 	A11 	A12	
B10 	B11 	B12
	
A20 	A21 	A22	
B20 	B21 	B22	
(1)对齐，将A的第i行向左循环移动i步，B的第j列向上循环移动j步，同一个块内的A和B进行乘运算
A00 	A01 	A02		
B00 	B11 	B22

A11 	A12 	A10		
B10 	B21 	B02

A22 	A20 	A21 	
B20 	B01 	B12
(2)将A的各行向左循环移动1步，B的各列向上循环移动1步， 同一个块内的A和B进行乘运算，每个块内的运算结果与上一步中的相加
A01 	A02		A00   
B10 	B21 	B02

A12 	A10 	A11
B20 	B01 	B12

A20 	A21 	A22
B00 	B11 	B22
(3)将A的各行向左循环移动1步，B的各列向上循环移动1步， 同一个块内的A和B进行乘运算，每个块内的运算结果与上一步中的相加
A02		A00   	A01 
B20 	B01 	B12

A10 	A11  	A12 
B00 	B11 	B22

A21 	A22  	A20
B10 	B21 	B02
(4)最后得到的C如下
A00B00+A01B10+A02B20 A01B11+A02B21+A00B01 A02B22+A00B02+A01B12
A11B10+A12B20+A10B00 A12B21+A10B01+A11B11 A10B02+A11B12+A12B22
A22B20+A20B00+A21B10 A20B01+A21B11+A22B21 A21B12+A22B22+A20B02




