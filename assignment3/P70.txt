1.
i, j, k, l, s, t应满足如下关系
i = k mod p
j = l mod q
s = k / p
t = l / q

2. 
矩阵A和向量b按行分块存储在p个处理器中，处理器pi中存了A的第i行Ai以及b的第i个元素bi，
所求x+=Ax+b，可以在处理器pi中求Ai和x的乘积，然后在pi中把求得的Aix和bi相加，pi中存的
即为x+的第i个元素。
无论第一次x在哪里，迭代后的x的块会分布在不同的处理器中
matvec.c

3.
题目假设传输长度为N的数据的复杂性为a+bN，广播数据按照树型方式进行
假设一次乘法的复杂性为c, 一次加法的复杂性为d
列列分块算法复杂性，假设A和B均为N*N矩阵
(1)初始时A的第i列Ai和Bi的第i列存在pi中，在pi中进行Ai*B[i][i]的运算,做了N次乘法，pi处的复杂性为cN，所有处理器的复杂性为N(cN)
(2)pi传送数据Ai给下一个处理器，同时pi也收到了来自其他处理器的Aj，pi处的复杂性a+bN，所有处理器的复杂性，a+bN^2
(3)pi进行Aj*B[j][i]的运算，做了N次乘法，一次加法，pi处的复杂性为cN+d，所有处理器的复杂性N(cN+d)
(4)步骤(2)和(3)重复N-1次，总的复杂性为N*(cN)+(N-1)(a+bN^2+N(cN+d))=(b+c)N^3+(d-b)N^2+(a-d)N-a


Cannon算法复杂性
若A和B各自分为N*N块
初始对齐移位，共传送数据1+2+...+N=(N^2+N)/2，复杂性a+b(N^2+N)/2
之后N次移位，每次移动N步，共传送数据N^2，复杂性a+bN^2
每次移位后，进行乘法和加法运算，运算复杂度为NcN^2+(N-1)dN^2
Cannon算法的复杂性 a+b(N^2+N)/2+a+bN^2+NcN^2+(N-1)dN^2=(c+d)N^3+(0.5b-d)N^2+0.5bN+2a






4.
请用自己的理解给出cannon算法的描述
cannon算法，首先，对矩阵A和矩阵B分块成Aij和Bij，并按行列对齐,矩阵A的块行循环移位，矩阵B的块列循环移位，使得A的第i行和B的第j列中的对应元素依次移位到ij块内，并相乘相加得到Cij
例如3*3分块矩阵A,B如下
A00 	A01 	A02
B00		B01 	B02

A10 	A11 	A12	
B10 	B11 	B12
	
A20 	A21 	A22	
B20 	B21 	B22	
(1)对齐，将A的第i行向左循环移动i步，B的第j列向上循环移动j步，同一个块内的A和B进行乘运算
A00 	A01 	A02		
B00 	B11 	B22

A11 	A12 	A10		
B10 	B21 	B02

A22 	A20 	A21 	
B20 	B01 	B12
(2)将A的各行向左循环移动1步，B的各列向上循环移动1步， 同一个块内的A和B进行乘运算，每个块内的运算结果与上一步中的相加
A01 	A02		A00   
B10 	B21 	B02

A12 	A10 	A11
B20 	B01 	B12

A20 	A21 	A22
B00 	B11 	B22
(3)将A的各行向左循环移动1步，B的各列向上循环移动1步， 同一个块内的A和B进行乘运算，每个块内的运算结果与上一步中的相加
A02		A00   	A01 
B20 	B01 	B12

A10 	A11  	A12 
B00 	B11 	B22

A21 	A22  	A20
B10 	B21 	B02
(4)最后得到的C如下
A00B00+A01B10+A02B20 A01B11+A02B21+A00B01 A02B22+A00B02+A01B12
A11B10+A12B20+A10B00 A12B21+A10B01+A11B11 A10B02+A11B12+A12B22
A22B20+A20B00+A21B10 A20B01+A21B11+A22B21 A21B12+A22B22+A20B02




